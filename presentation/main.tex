%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES
%----------------------------------------------------------------------------------------

\documentclass{beamer}

\mode<presentation> {

% The Beamer class comes with a number of default slide themes
% which change the colors and layouts of slides. Below this is a list
% of all the themes, uncomment each in turn to see what they look like.

%\usetheme{CambridgeUS}
\usetheme{Madrid}
%\usetheme{Singapore}

% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.


%\usecolortheme{dolphin}
%\usecolortheme{orchid}
%\usecolortheme{seahorse}
%\usecolortheme{whale}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{mathtools,amssymb}
\usepackage{marvosym}
\usepackage[marvosym]{tikzsymbols}
\usepackage{tabto}
\usepackage{nccmath}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[SSB Investigation]{A Cryptographic Investigation of Secure Scuttlebutt} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{Oleksandra Lapiha}
\institute[ENS]
{DIENS, \'Ecole normale sup\'erieure, Paris, France  \\
\medskip
\textit{oleksandra.lapiha@ens.fr}
}
\date{2 September 2019}

\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

%\begin{frame}
%\frametitle{Overview} % Table of contents slide, comment this block out to remove it
%\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
%\end{frame}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

%------------------------------------------------
\section{Secure Scuttlebutt}
%------------------------------------------------

\subsection{Protocol overview}

%------------------------------------------------

\begin{frame}{What is Secure Scutllebutt}
%\begin{flushright}
%    \includegraphics[width=5cm]{scuttlebuttlogo}%\vskip3cm\hskip2cm
%\end{flushright}
ToDo: include animation!
\begin{center}
    \textit{decentralized secure gossip platform}
\end{center}
\begin{itemize}
    \item No central authority controls the network
    \item Ambitious security goals!
    \item Peer-to-peer communication is based on the "epidemic spread"
    \item Framework for building applications
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{Core concepts}
\begin{itemize}
    \item Scuttlebutt client - a member of a Scuttlebutt network.
    \item Message feed - A sequence of blocks of information chainde by a hash function. (ToDo - insert a picture)
    \item Pub - Scuttlebutt client which is run on the server and assumed to be always online.
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{Scullebutt's Functionality}
\begin{itemize}
    \item Synchronising message feeds over a local network
    \item Pubs as a way to synchronise with remote peers
    \item Following message feeds
    \item Private group chats for 2 to 7 participants
    \item Private Scuttlebutt networks
    \item Operating fully offline
\end{itemize}
\end{frame}

%------------------------------------------------

%\begin{frame}{Applications}
%\begin{itemize}
%    \item Social network
%    \item File sharing
%    \item GitHub
%    \item Chess
%\end{itemize}
%\end{frame}

%------------------------------------------------

\subsection{Motivation}

%------------------------------------------------

\begin{frame}{Security goals.}
\begin{itemize}
    \item Mutual authentication
    %\item Abort before confirming identity
    \item Identity hiding
    \item Network identifier hiding
    \item Network confirmation
    \item Replay attack resistance
    \item Forward secrecy
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}{Protocol Structure}
\begin{itemize}
    \item The Handshake
    \item Invites
    \item Private Messaging
\end{itemize}
\end{frame}



\begin{frame}{Symbolic Model}
    %Dolev-Yao model?
    In the \textit{symbolic verification model} the cryptographic primitives are represented by function symbols considered as \textit{perfect black-boxes}, the messages are abstract terms,
    and the adversary is restricted to compute only the primitives defined by the user. \\


    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{enc}(\mathsf{bitstring}, \mathsf{key}):\ \mathsf{bitstring}. \\
        \mathsf{fun}\ \mathsf{dec}(\mathsf{bitstring}, \mathsf{key}):\ \mathsf{bitstring} \\
        \mathsf{reduc}\ \mathsf{forall}\ m:\ \mathsf{bitstring},\ k:\ \mathsf{key}; \\
        \mathsf{dec}(\mathsf{enc}(m),k) = m \\
    \end{array}\end{equation*}

\end{frame}

%------------------------------------------------

\begin{frame}{ProVerif}
\begin{itemize}
    \item \textit{ProVerif} - fully automated symbolic protocol verifier
    \item Proving strategy: search for a protocol trace that violates the security goal
    \item Developped by \textit{Bruno Blanchet and Vincent Cheval} in Inria, Paris.
    \item Protocols are described in applied pi-calculus.
    \item The structure of the model: $\Sigma = \Delta_1. \ldots \Delta_n P$
    \item Where $\Delta_i$ is a declaration of the : \textit{type, free name, query, constructor, destructor, equation, pure function or a process}
    \item And $P$ is a top level process.
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{Verifpal?}


\end{frame}


%------------------------------------------------
\section{Our Contributions}
%------------------------------------------------

\subsection{Modeling in ProVerif}

%------------------------------------------------

\begin{frame}{Primitives. Modeling Unexpected behaviours}
  \begin{fleqn}[\parindent]
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{get\_pk}(\mathsf{sk}):\ \mathsf{pk}. \\
        \mathsf{fun}\ \mathsf{sign}(\mathsf{bitstring},\ \mathsf{sk}):\ \mathsf{bitstring}. \\
        \mathsf{fun}\ \mathsf{checksign}(\mathsf{bitstring},\ \mathsf{pk},\ \mathsf{bitstring}):\ \mathsf{bool} \\
        \mathsf{reduc}\ \mathsf{forall}\ m:\ \mathsf{bitstring},\ k:\ \mathsf{sk}; \\
        \mathsf{checksign}(\mathsf{sign}(m,k),\ \mathsf{get\_pk}(k),\ m)\ =\ \mathsf{true} \\
    \end{array}\end{equation*}
  \end{fleqn}
\end{frame}

\begin{frame}{Primitives. Modeling Unexpected behaviours}
  \begin{fleqn}[\parindent]
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{get\_pk}(\mathsf{sk}):\ \mathsf{pk}. \\
        \mathsf{fun}\ \mathsf{weak}(\mathsf{sk}):\ \mathsf{sk}. \\
    \end{array}\end{equation*}
  \end{fleqn}
  \begin{fleqn}[\parindent]
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{sign}(\mathsf{bitstring},\ \mathsf{sk}):\ \mathsf{bitstring}. \\
        \mathsf{fun}\ \mathsf{checksign}(\mathsf{bitstring},\ \mathsf{pk},\ \mathsf{bitstring}):\ \mathsf{bool} \\
        \mathsf{reduc}\ \mathsf{forall}\ m:\ \mathsf{bitstring},\ k:\ \mathsf{sk}; \\ \mathsf{checksign}(\mathsf{sign}(m,k),\ \mathsf{get\_pk}(k),\ m)\ =\ \mathsf{true} \\
        \mathsf{otherwise}\ \mathsf{forall}\ m1:\ \mathsf{bitstring},\ m2:\mathsf{bitstring},\ k: \ \mathsf{sk};\\
        \mathsf{checksign}(\mathsf{sign}(m1,\ \mathsf{weak}(k)),\ \mathsf{get\_pk}(\mathsf{weak}(k)),\ m2)\ =\ \mathsf{true}\\
    \end{array}\end{equation*}
  \end{fleqn}
\end{frame}

\begin{frame}{Primitives. Modeling Unexpected behaviours}
  \begin{fleqn}[\parindent]
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{get\_pk}(\mathsf{sk}):\ \mathsf{pk}. \\
    \end{array}\end{equation*}
  \end{fleqn}
  \begin{fleqn}[\parindent]
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{exp}(\mathsf{pk},\ \mathsf{sk}):\ \mathsf{sym\_key}.\\
        \mathsf{equation}\ \mathsf{forall}\ x:\mathsf{sk},\ y:\mathsf{sk};\\ \mathsf{exp}(\mathsf{get\_pk}(x),\ y)\ =\ \mathsf{exp}(\mathsf{get\_pk}(y),\ x).\\
    \end{array}\end{equation*}
  \end{fleqn}
\end{frame}


\begin{frame}{Primitives. Modeling Unexpected behaviours}

\begin{fleqn}[\parindent]
    \begin{equation*}
      \mathsf{const}\ \mathsf{zero}:\mathsf{sym\_key}\ [\mathsf{data}].
    \end{equation*}
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{get\_pk}(\mathsf{sk}):\ \mathsf{pk}. \\
        \mathsf{fun}\ \mathsf{weak}(\mathsf{sk}):\ \mathsf{sk}. \\
    \end{array}\end{equation*}
\end{fleqn}
\begin{fleqn}[\parindent]
    \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{exp}(\mathsf{pk},\ \mathsf{sk}):\ \mathsf{sym\_key}.\\
        \mathsf{equation}\ \mathsf{forall}\ x:\mathsf{sk},\ y:\mathsf{sk};\ \mathsf{exp}(\mathsf{get\_pk}(x),\ y)\ =\ \mathsf{exp}(\mathsf{get\_pk}(y),\ x).\\
   \end{array}\end{equation*}
\end{fleqn}
   \begin{equation*}\begin{array}{l}
        \mathsf{fun}\ \mathsf{dhexp}(\mathsf{pk},\ \mathsf{sk}):\ \mathsf{sym\_key}\\
        \mathsf{reduc}\ \mathsf{forall}\ b:\mathsf{sk},\ a:\mathsf{sk};\ \mathsf{dhexp}(\mathsf{get\_pk}(\mathsf{weak}(a)),\ b)\ =\ \mathsf{zero}\\
        \mathsf{otherwise}\ \mathsf{forall}\ b:\mathsf{sk}, a:\mathsf{sk};\ \mathsf{dhexp}(\mathsf{get\_pk}(a),\ \mathsf{weak}(b))\ =\ \mathsf{zero}\\
        \mathsf{otherwise}\ \mathsf{forall}\ b:\mathsf{sk},\ a:\mathsf{sk};\ \mathsf{dhexp}(\mathsf{get\_pk}(a),\ b)\ =\ \mathsf{exp}(\mathsf{get\_pk}(a),\ b).\\
    \end{array}\end{equation*}
\end{frame}

%------------------------------------------------

\begin{frame}{Handshake}
  \includegraphics[width=10cm, height=8cm]{handshake.png}
\end{frame}

%------------------------------------------------

\begin{frame}{Queries}
  \begin{enumerate}
    \item  Mutual authentication
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Shared secret agreement
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Identity hiding(\& Replay attack resistance)
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Network identifier hiding
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Network confirmation
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Forward secrecy
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \end{enumerate}
\end{frame}

%------------------------------------------------

\begin{frame}{Small Subgroup Attack}
Here we consider network identifier $N$ to be public.
\begin{itemize}
  \item The attacker chooses his longterm and ephemeral key pairs to be weak.
  \item The attacker derives a shared secret with Bob which is now a constant value
  \item The attacker signes a random message with his key, the signature verifies against any message.
  \item The final derived shared secret is a constant, so it is know by the attacker, rendering it usable to encrypt messages to Bob.
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{Queries}
  \begin{enumerate}
    \item  Mutual authentication
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item \alert{Shared secret agreement}
      {\tabto{8cm}\textcolor{red!80!black}{{\large\CrossedBox}}}
    \item Identity hiding(\& Replay attack resistance)
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Network identifier hiding
      {\tabto{8cm}\textcolor{red!80!black}{{\large\CrossedBox}}}
    \item Network confirmation
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item \alert{Forward secrecy}
      {\tabto{8cm}\textcolor{red!80!black}{{\large\CrossedBox}}}
    \end{enumerate}
\end{frame}

%------------------------------------------------

\begin{frame}{Invite Redemption}
\begin{itemize}
  \item Alice uses the invite key pair instead of her long-term key pair.
  \item Alice does not send any message to the Pub after the invitation code is used
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{Queries}
  \begin{enumerate}
    \item \alert{Mutual authentication}
      {\tabto{8cm}\textcolor{red!80!black}{{\large\CrossedBox}}}
    \item Identity hiding(\& Replay attack resistance)
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Network identifier hiding
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Network confirmation
      {\tabto{8cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \end{enumerate}
\end{frame}

%------------------------------------------------

\begin{frame}{Private Messaging}
  \includegraphics[width=9cm, height=8cm]{private_messaging.png}
\end{frame}

\begin{frame}{Private Messaging: Model}
  \begin{enumerate}
  	\item $\mathsf{EncryptM42}(skMe:\mathsf{sk},\ pkReceiver1:\mathsf{pk},\ pkReceiver2:\mathsf{pk},\ m\_out: \mathsf{bitstring})$
  	\item $\mathsf{DecryptM42}(skMe:\mathsf{sk},\ pkSender:\mathsf{pk})$
  	\item $\mathsf{EncryptM42}(skMe:\mathsf{sk},\ pkReceiver1:\mathsf{pk},\ m\_out: \mathsf{bitstring})$
  	\item $\mathsf{DecryptM41}(skMe:\mathsf{sk},\ pkSender:\mathsf{pk})$
  \end{enumerate}
\end{frame}

\begin{frame}{Queries}
  \begin{enumerate}
    \item Message authentication
      {\tabto{6cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
    \item Forward secrecy
      {\tabto{6cm}\textcolor{green!80!black}{{\large\Checkedbox}}}
  \end{enumerate}
\end{frame}

%------------------------------------------------

\subsection{Modeling in CryptoVerif}

%------------------------------------------------

\begin{frame}{Computational Model}
    In \textit{computational model} an adversary is a \textit{probabilistic Turing machine}. It is restricted to run in
polynomial time in security parameter. The security property holds if it can only occur with \textit{negligible probability} in security parameter.
    We discuss the primitives with respect to underlying cryptographic assumptions.
    \begin{equation*}\begin{array}{l}
        \mathsf{expand}\ \mathsf{IND\_CPA\_sym\_enc}(\mathsf{key},\ \mathsf{cleartext},\ \mathsf{ciphertext},\\
        \mathsf{enc},\ \mathsf{dec},\ \mathsf{injbot},\ \mathsf{Z},\ \mathsf{Penc})
    \end{array}\end{equation*}
\end{frame}

%------------------------------------------------

\begin{frame}{Game-based Proofs}
  \begin{itemize}
    \item given: a game betweent the adversary and a challenger
    \item goal: prove advesary's advantage is negligible
    \item game hopping: sequence of indistiguishable transformations of the initial game, such that for the final game the advatage is easy to upperbound.
    \item transformations:
    \begin{itemize}
      \item Transitions based on indistinguishability
      \item Transitions based on failure event
      \item Bridging steps
    \end{itemize}
  \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{CryptoVerif}
\begin{itemize}
    \item \textit{CryptoVerif} - semi-automated computational protocol verifier
    \item Proving strategy: generates a chain of indistinguishable games with aim to obtain a game where the property hold trivially
    \item Developped by \textit{Bruno Blanchet and David Cadé} in Inria, Paris.
    \item Protocols are described in applied pi-calculus.
    \item The syntax and the structure of protocol description is very close to ProVerif
\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}{Results}
  \begin{itemize}
    \item The Handshake (Initiator Authentication and Network Confirmation)
    \begin{theorem}
      If the initiator of the communication is able to complete the session it is authenticated to the responder. When parties complete the key exchange they agree on the network identifier.
    \end{theorem}
  \item Invites (Client Authentication and Network Confirmation)
    \begin{theorem}
      If the client is able to complete the session, then his invitation key is accepted by the Pub. If parties were able to complete the protocol, then they agree on the network identifier.
    \end{theorem}
  \end{itemize}
\end{frame}

%------------------------------------------------
\section{Future Work}
%------------------------------------------------

\begin{frame}{Future Work}
  Assist the proof by CryptoVerif to:
  \begin{itemize}
    \item Prove more queries for existing models
    \item Model the private messaging protocol
  \end{itemize}
\end{frame}

\begin{frame}
\Huge{\centerline{Thank You!}}
\end{frame}

%----------------------------------------------------------------------------------------

\end{document}
